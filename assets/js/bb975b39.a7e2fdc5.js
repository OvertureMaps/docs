"use strict";(self.webpackChunkoverture_documentation=self.webpackChunkoverture_documentation||[]).push([[9066],{27125:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"gers/gers-tutorial","title":"GERS Tutorial","description":"Why associate your data with GERS identifiers?","source":"@site/docs/gers/gers-tutorial.mdx","sourceDirName":"gers","slug":"/gers/gers-tutorial","permalink":"/gers/gers-tutorial","draft":false,"unlisted":false,"tags":[],"version":"current","lastUpdatedAt":1746040070000,"frontMatter":{"title":"GERS Tutorial"},"sidebar":"docs","previous":{"title":"Stability by Feature Type","permalink":"/gers/stability"},"next":{"title":"Attribution and Licensing","permalink":"/attribution"}}');var t=n(74848),s=n(28453);const r={title:"GERS Tutorial"},o=void 0,d={},c=[{value:"Why associate your data with GERS identifiers?",id:"why-associate-your-data-with-gers-identifiers",level:2},{value:"Process overview",id:"process-overview",level:2},{value:"Performing an initial match",id:"performing-an-initial-match",level:2},{value:"Planning our match",id:"planning-our-match",level:3},{value:"Staging our datasets",id:"staging-our-datasets",level:3},{value:"Matching our data",id:"matching-our-data",level:3},{value:"Enriching data with GERS IDs &amp; producing a bridge file",id:"enriching-data-with-gers-ids--producing-a-bridge-file",level:2},{value:"Enriching our table",id:"enriching-our-table",level:3},{value:"Producing a bridge file",id:"producing-a-bridge-file",level:3},{value:"Performing a maintenance match",id:"performing-a-maintenance-match",level:2},{value:"Associating with every monthly release",id:"associating-with-every-monthly-release",level:3},{value:"Overture data changelog",id:"overture-data-changelog",level:3},{value:"Finding a Subset of Records That Need Matching",id:"finding-a-subset-of-records-that-need-matching",level:3},{value:"Matching Unmatched records to the latest release",id:"matching-unmatched-records-to-the-latest-release",level:4},{value:"Summary",id:"summary",level:2}];function l(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.h2,{id:"why-associate-your-data-with-gers-identifiers",children:"Why associate your data with GERS identifiers?"}),"\n",(0,t.jsx)(i.p,{children:"Overture Data isn\u2019t just a base layer for building your own map, it\u2019s a shared reference layer for exchanging and enriching geospatial data. The Global Entity Reference System (GERS) is the framework that enables this exchange. Every datapoint in Overture data releases has a GERS identifier, a persistent value referencing itself."}),"\n",(0,t.jsx)(i.p,{children:"The Overture Maps Foundation doesn\u2019t just produce a collection of open datasets, it defines a reference system for exchanging and enriching geospatial data. This reference system, called GERS (Geospatial Entity Reference System), provides persistent unique identifiers for each map feature in Overture\u2019s dataset."}),"\n",(0,t.jsx)(i.p,{children:"By matching your data to Overture\u2019s and attaching GERS identifiers to your datapoints, you can seamlessly share and connect your data with other GERS-associated datasets."}),"\n",(0,t.jsx)(i.h2,{id:"process-overview",children:"Process overview"}),"\n",(0,t.jsx)(i.p,{children:"To associate your data with GERS identifiers, we need to:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"Perform an initial association between your data and a relevant Overture theme."}),"\n",(0,t.jsx)(i.li,{children:"Add GERS identifiers to your dataset as a column or produce a \u201cbridge file\u201d mapping your data identifiers to their corresponding GERS identifiers."}),"\n",(0,t.jsx)(i.li,{children:"Perform a regular maintenance match, usually with every monthly Overture release."}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Joining geospatial datasets is a highly context dependent task. Sometimes you want very precise matches, with little risk of false positives. And other times you want greedy, loose matches, with wide coverage. To demonstrate this context dependency, we\u2019ll be adopting the following use case to frame our decisions:"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsxs)(i.em,{children:["We\u2019re building a hyperlocal mobile application that allows people to browse restaurants in Alameda County. Users can search for, browse, bookmark, and share restaurants. We will be using ",(0,t.jsx)(i.a,{href:"https://docs.overturemaps.org/guides/places/",children:"Overture\u2019s Places theme"})," as our foundational dataset, but we want to bring in additional datasets to add details to our restaurant listings."]})}),"\n",(0,t.jsxs)(i.p,{children:["One dataset we want to add is ",(0,t.jsx)(i.a,{href:"https://data.acgov.org/datasets/e95ff2829e9d4ea0b3d8266aac37ff14_0/explore",children:"Alameda County\u2019s restaurant inspection reports"}),", a dataset detailing the health and safety scores for each restaurant. This data will allow our users to filter restaurants by their health scores and present these health scores in our restaurant profiles."]}),"\n",(0,t.jsx)(i.p,{children:"The following tutorial walks through how to join this dataset to Overture Places, both as a one-off connection and an ongoing match process."}),"\n",(0,t.jsx)(i.h2,{id:"performing-an-initial-match",children:"Performing an initial match"}),"\n",(0,t.jsx)(i.h3,{id:"planning-our-match",children:"Planning our match"}),"\n",(0,t.jsx)(i.p,{children:"Alameda County produces and publishes a dataset detailing restaurant inspections. These records are regularly updated and specify the current \u201chealth score\u201d of a given venue. The county publishes these records in a variety of formats; today we\u2019ll be using their GeoJSON distribution."}),"\n",(0,t.jsx)(i.p,{children:"In the GeoJSON file, records are stored as features. For example:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-javascript",children:'{\n           "type": "Feature",\n           "id": 3,\n           "geometry": {\n               "type": "Point",\n               "coordinates": [\n                   -122.056105500269,\n                   37.6374869997196\n               ]\n           },\n           "properties": {\n               "OBJECTID": 3,\n               "Facility_ID": "FA0319719",\n               "ExternalID": 827161,\n               "Facility_Name": "LALO\'S TAQUERIA",\n               "Address": "28293 MISSION BLVD",\n               "City": "HAYWARD",\n               "State": "CA",\n               "Zip": "94544",\n               "Activity_Date": "2024-01-18",\n               "Service": "111",\n               "Violation_Description": "Food in good condition, safe and unadulterated",\n               "Grade": "G",\n               "Longitude": -122.0561055,\n               "Latitude": 37.637487\n           }\n       }\n'})}),"\n",(0,t.jsxs)(i.p,{children:["If you\u2019re following along, go ahead and download ",(0,t.jsx)(i.a,{href:"https://data.acgov.org/datasets/e95ff2829e9d4ea0b3d8266aac37ff14_0/explore?location=37.676900%2C-122.008949%2C10.04",children:"the GeoJSON data from Alameda County\u2019s portal"}),"."]}),"\n",(0,t.jsx)(i.p,{children:"Inspection records are associated with restaurants and eateries, so it makes sense to associate these records with Overture\u2019s Places theme."}),"\n",(0,t.jsx)(i.p,{children:"In the Places dataset, the record which matches the inspection example above looks like this, in GeoJSON form:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-javascript",children:'{\n   "type": "Feature",\n   "geometry": {\n       "type": "Point",\n       "coordinates": [\n           -122.056054,\n           37.63755\n       ]\n   },\n   "properties": {\n       "id": "08f28346e8ca018503160340e65ac7b6",\n       "type": "place",\n       "version": 0,\n       "sources": [\n           {\n               "property": "",\n               "dataset": "meta",\n               "record_id": "103711722756889",\n               "update_time": "2025-02-24T08:00:00.000Z",\n               "confidence": 0.9793990828827596\n           }\n       ],\n       "names": {\n           "primary": "Lalo\'s Taqueria",\n           "common": null,\n           "rules": null\n       },\n       "categories": {\n           "primary": "mexican_restaurant",\n           "alternate": [\n               "restaurant",\n               "eat_and_drink"\n           ]\n       },\n       "confidence": 0.9793990828827596,\n       "socials": [\n           "https://www.facebook.com/103711722756889"\n       ],\n       "phones": [\n           "+15109400137"\n       ],\n       "addresses": [\n           {\n               "freeform": "28293 Mission Blvd",\n               "locality": "Hayward",\n               "postcode": "94544-4853",\n               "region": "CA",\n               "country": "US"\n           }\n       ]\n   }\n}\n'})}),"\n",(0,t.jsx)(i.p,{children:"Comparing the schema of each, we can see there are a few elements we can reference during our match:"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"schema-comparison",src:n(84708).A+"",width:"1146",height:"794"})}),"\n",(0,t.jsx)(i.p,{children:"Using these common attributes, and a bit of SQL, we can quickly spin up a quick matcher using DuckDB."}),"\n",(0,t.jsx)(i.h3,{id:"staging-our-datasets",children:"Staging our datasets"}),"\n",(0,t.jsxs)(i.p,{children:["With our inspection data saved as ",(0,t.jsx)(i.code,{children:"inspection_records.geojson"}),", let\u2019s boot up DuckDB, specifying a local database as a cache."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"$ duckdb inspection_match.ddb\n"})}),"\n",(0,t.jsxs)(i.p,{children:["We\u2019ll load the ",(0,t.jsx)(i.code,{children:"spatial"})," and ",(0,t.jsx)(i.code,{children:"httpfs"})," plug-ins, then load our inspections into a local table."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"D install spatial;\nD load spatial;\nD install httpfs;\nD load httpfs;\nD CREATE TABLE IF NOT EXISTS inspections AS SELECT * FROM ST_Read('inspection_records.geojson');\n"})}),"\n",(0,t.jsx)(i.p,{children:"Since there are multiple inspections for each venue, and we want to match each venue to an Overture Place, we\u2019re going to create a separate table just for the facilities."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"D CREATE TABLE IF NOT EXISTS facilities AS \n  SELECT Facility_ID, Facility_Name, Address, City, State, Zip, geom\n  FROM inspections\n  GROUP BY Facility_ID, Facility_Name, Address, City, State, Zip, geom;\n"})}),"\n",(0,t.jsx)(i.admonition,{type:"note",children:(0,t.jsx)(i.p,{children:"We\u2019re only pulling in each facility's ID and the columns which overlap with Overture\u2019s Places."})}),"\n",(0,t.jsx)(i.p,{children:"Geospatial matching processes can get quite complex, so we\u2019re going to load the Overture data we need in a local table before attempting any joins."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"D CREATE TABLE IF NOT EXISTS places AS \n  WITH bounding_box AS (\n    SELECT max(ST_Y(geom)) as max_lat, \n           min(ST_Y(geom)) as min_lat, \n           max(ST_X(geom)) as max_lon, \n           min(ST_X(geom)) as min_lon\n    FROM facilities\n  )\n  SELECT \n    id, \n    upper(names['primary']) as Facility_Name, \n    upper(addresses[1]['freeform']) as Address, \n    upper(addresses[1]['locality']) as City, \n    upper(addresses[1]['region']) as State, \n    left(addresses[1]['postcode'], 5) as Zip, \n    geometry as geom, \n    categories,\n    confidence \n  FROM (\n    SELECT * \n    FROM read_parquet('s3://overturemaps-us-west-2/release/2025-03-19.1/theme=places/type=place/*', filename=true, hive_partitioning=1),\n      bounding_box\n    WHERE addresses[1] IS NOT NULL \n      AND bbox.xmin BETWEEN (bounding_box.min_lon - 0.01) AND (bounding_box.max_lon + 0.01)\n      AND bbox.ymin BETWEEN (bounding_box.min_lat - 0.01) AND (bounding_box.max_lat + 0.01)\n  );\n"})}),"\n",(0,t.jsx)(i.p,{children:"We\u2019re doing several things here that are worth breaking down:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsx)(i.li,{children:"We create a bounding box by computing the maximum and minimum latitude and longitude values of our inspections. This ensures we\u2019re only pulling Overture Places relevant to our input dataset."}),"\n",(0,t.jsxs)(i.li,{children:["Our following ",(0,t.jsx)(i.code,{children:"SELECT"})," statement prepares the Places data to more closely align with the conventions of our inspections data: the ",(0,t.jsx)(i.code,{children:"addresses"})," column is broken down into component columns and we use only the primary name from the ",(0,t.jsx)(i.code,{children:"names"})," column and label it to match ",(0,t.jsx)(i.code,{children:"Facility_Name"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:["Finally, we obtain the data from the Overture S3 bucket by remotely reading the parquet. A ",(0,t.jsx)(i.code,{children:"WHERE"})," statement limits our request to a slightly buffered bounding box (buffered to ensure we\u2019re capturing places near those facilities on the edges of our dataset)."]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["We now have three tables: ",(0,t.jsx)(i.code,{children:"inspections"})," with 27,515 records, ",(0,t.jsx)(i.code,{children:"facilities"})," with 4,340 records, and ",(0,t.jsx)(i.code,{children:"places"})," with 73,985 records."]}),"\n",(0,t.jsx)(i.p,{children:"Before we work on connecting them, we\u2019ll add some spatial indexes to each table, making our lookups much faster:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"D CREATE INDEX IF NOT EXISTS idx_places_geometry ON places USING RTREE (geom);\nD CREATE INDEX IF NOT EXISTS idx_facilities_geometry ON facilities USING RTREE (geom);\n"})}),"\n",(0,t.jsx)(i.h3,{id:"matching-our-data",children:"Matching our data"}),"\n",(0,t.jsxs)(i.p,{children:["Geospatial matching can be a simple or very complicated process. A simple join might just be a couple ",(0,t.jsx)(i.code,{children:"WHERE"})," statements, while a complicated process might employ a compound pipeline with  Bayesian comparisons, vector search, LLMs, and/or human reviewers. It all depends on your use case."]}),"\n",(0,t.jsxs)(i.p,{children:["Geospatial matching can also be ",(0,t.jsx)(i.em,{children:"greedy"})," or ",(0,t.jsx)(i.em,{children:"cautious"}),". A greedy matching routine will have less stringent standards and err towards making mismatches, whereas a cautious match will apply strict standards and err towards missing a correct match."]}),"\n",(0,t.jsx)(i.p,{children:"What type of match you employ \u2014 simple or complicated, greedy or cautious \u2014 requires you to understand how your data is being used, the cost of a false positive, and more. This is to say: it\u2019s a decision beyond the scope of this tutorial."}),"\n",(0,t.jsxs)(i.p,{children:["For our example, we will be constructing a ",(0,t.jsx)(i.em,{children:"simple cautious"})," matcher. We\u2019ve chosen to build a cautious matcher because our data describes inspection scores and violations; the cost of a false match is ",(0,t.jsx)(i.em,{children:"high"}),". It is safer for us to show ",(0,t.jsx)(i.em,{children:"no"})," health score than show a ",(0,t.jsx)(i.em,{children:"failing"})," one for a restaurant that did not fail."]}),"\n",(0,t.jsx)(i.p,{children:"But to get started, we will write a join using three conditions with very loose thresholds. We\u2019ll break down each condition below."}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"D SELECT \n    f.Facility_ID as input_id, \n    f.Facility_Name as input_name, \n    f.Address as input_address, \n    p.id as match_id, \n    p.Facility_Name as match_name, \n    p.Address as match_address,\n    p.confidence as overture_confidence,\n    ST_Distance_Sphere(f.geom, p.geom) as distance, \n    jaro_winkler_similarity(f.Facility_Name, p.Facility_Name) as name_similarity, \n    jaro_winkler_similarity(f.Address, p.Address) as address_similarity\n  FROM facilities f\n  JOIN places p\n    ON ST_DWithin(f.geom, p.geom, 0.001)\n    AND jaro_winkler_similarity(f.Facility_Name, p.Facility_Name) > 0.7\n    AND jaro_winkler_similarity(f.Address, p.Address) > 0.8\n  ORDER BY f.Facility_ID, distance;\n"})}),"\n",(0,t.jsxs)(i.p,{children:["Scanning down to the ",(0,t.jsx)(i.code,{children:"JOIN"})," statement, we are using three comparisons to associate our records:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Is it close by?"})," ",(0,t.jsx)(i.code,{children:"ST_DWithin(f.geom, p.geom, 0.005)"}),": This matches records if they\u2019re within ~100 meters from each other (this is what 0.001 roughly equates to in our ",(0,t.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Spatial_reference_system",children:"SRID"}),")"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Do the names match?"})," ",(0,t.jsx)(i.code,{children:"jaro_winkler_similarity(f.Facility_Name, p.Facility_Name) > 0.7"}),": This is a ",(0,t.jsx)(i.a,{href:"https://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance",children:"string comparison function"})," that generates a score from 0.0 to 1.0, with 1.0 being an exact match. Here we\u2019re comparing the listed name for each record. We\u2019ve chosen the Jaro-Winkler metric because it weights the beginning of strings higher than the end of strings, which tends to work well here."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Do the addresses match?"})," ",(0,t.jsx)(i.code,{children:"jaro_winker_similarity(f.Address, p.Address) > 0.8"}),": We\u2019re using the same function as the previous comparison, just with a slightly higher threshold, to compare our addresses."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"With just this query, we can get pretty far. There are three levers \u2014 the values specified for each of the three statements above \u2014 that we can tweak until we\u2019re close to good."}),"\n",(0,t.jsxs)(i.p,{children:["At this point, it\u2019s helpful to look at the data yourself. I usually use ",(0,t.jsx)(i.a,{href:"https://duckdb.org/docs/stable/guides/file_formats/csv_export.html",children:"DuckDB\u2019s CSV export function"})," and scan the results, looking for patterns to inform tweaking our parameters."]}),"\n",(0,t.jsx)(i.p,{children:"For example, here are 3 candidate Overture Places which match with \u201cThornhill Coffee Shop\u201d, located at 5772 Thornhill Drive."}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Name"}),(0,t.jsx)(i.th,{children:"Address"}),(0,t.jsx)(i.th,{children:"Distance"}),(0,t.jsx)(i.th,{children:"Name Similarity"}),(0,t.jsx)(i.th,{children:"Address Similarity"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"THORNHILL COFFEE HOUSE"}),(0,t.jsx)(i.td,{children:"5772 THORNHILL DR"}),(0,t.jsx)(i.td,{children:"35.52"}),(0,t.jsx)(i.td,{children:"0.96"}),(0,t.jsx)(i.td,{children:"1.00"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"THORNHILL SALON"}),(0,t.jsx)(i.td,{children:"5736 THORNHILL DR"}),(0,t.jsx)(i.td,{children:"41.46"}),(0,t.jsx)(i.td,{children:"0.85"}),(0,t.jsx)(i.td,{children:"0.93"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"THORNHILL PET HOSPITAL"}),(0,t.jsx)(i.td,{children:"5745 THORNHILL DR"}),(0,t.jsx)(i.td,{children:"70.93"}),(0,t.jsx)(i.td,{children:"0.87"}),(0,t.jsx)(i.td,{children:"0.93"})]})]})]}),"\n",(0,t.jsx)(i.p,{children:"Here, everything is functioning as it should be. Even though our matcher is looser (it\u2019s letting in the two wrong candidates), the distance, name similarity, and address similarity metrics allow us to easily order our results and allow the correct record to bubble up."}),"\n",(0,t.jsx)(i.p,{children:"But elsewhere, this is not the case. Consider this example for matches with \u201cWest Oakland Senior Center\u201d, 1724 Adeline Street:"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"Name"}),(0,t.jsx)(i.th,{children:"Address"}),(0,t.jsx)(i.th,{children:"Distance"}),(0,t.jsx)(i.th,{children:"Name Similarity"}),(0,t.jsx)(i.th,{children:"Address Similarity"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"WEST OAKLAND BRANCH"}),(0,t.jsx)(i.td,{children:"1801 ADELINE ST"}),(0,t.jsx)(i.td,{children:"55.85"}),(0,t.jsx)(i.td,{children:"0.87"}),(0,t.jsx)(i.td,{children:"0.88"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"WEST OAKLAND JOB RESOURCE CENTER"}),(0,t.jsx)(i.td,{children:"1801 ADELINE ST"}),(0,t.jsx)(i.td,{children:"56.17"}),(0,t.jsx)(i.td,{children:"0.90"}),(0,t.jsx)(i.td,{children:"0.88"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"WEST OAKLAND SENIOR CENTER"}),(0,t.jsx)(i.td,{children:"1724 ADELINE ST"}),(0,t.jsx)(i.td,{children:"64.24"}),(0,t.jsx)(i.td,{children:"1.0"}),(0,t.jsx)(i.td,{children:"1.0"})]})]})]}),"\n",(0,t.jsx)(i.p,{children:"In this example, ranking in descending order of distance puts the correct match at the bottom. This cluster of match candidates suggests a perfect match for name and address should overrule slight distance differences."}),"\n",(0,t.jsx)(i.p,{children:"Reviewing these cluster candidates is essential work when building a matcher. As you plot and peruse them, patterns will emerge, enabling you to better tune your parameters."}),"\n",(0,t.jsx)(i.p,{children:"For larger matches \u2014 beyond the scale of ~4,000 restaurants in a single county \u2014 we recommend building evaluation test sets: human-verified correct and incorrect match pairs for a sample of your data. With an evaluation test set, one can more systematically tweak their matcher and quantitatively measure their performance."}),"\n",(0,t.jsxs)(i.p,{children:["But for our restaurant app scenario, we\u2019re fine with a quick match to populate our listings. After reviewing the data and running a few adjusted queries, we landed on an effective ",(0,t.jsx)(i.em,{children:"simple conservative"})," matcher query:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"WITH ranked_matches AS (\nSELECT \n    f.Facility_ID as input_id, \n    f.Facility_Name as input_name, \n    f.Address as input_address, \n    p.id as match_id, \n    p.Facility_Name as match_name, \n    p.Address as match_address,\n    p.confidence as overture_confidence,\n    ST_Distance_Sphere(f.geom, p.geom) as distance, \n    jaro_winkler_similarity(f.Facility_Name, p.Facility_Name) as name_similarity, \n    jaro_winkler_similarity(f.Address, p.Address) as address_similarity,\n    ROW_NUMBER() OVER (\n      PARTITION BY f.Facility_ID\n      ORDER BY jaro_winkler_similarity(f.Facility_Name, p.Facility_Name) DESC\n    ) as rank\n  FROM facilities f\n  JOIN places p\n    ON ST_DWithin(f.geom, p.geom, 0.001)\n    AND jaro_winkler_similarity(f.Facility_Name, p.Facility_Name) > 0.89\n    AND jaro_winkler_similarity(f.Address, p.Address) > 0.75\n)\nSELECT * FROM ranked_matches WHERE rank = 1\n"})}),"\n",(0,t.jsxs)(i.p,{children:["This query yields 2,358 correct matches and no false positives, for a match rate of 55%. By adding more conditionals and stages, we could get much higher results (if you\u2019d like the details about that, ",(0,t.jsx)(i.a,{href:"https://www.dbreunig.com/2024/09/27/conflating-overture-points-of-interests-with-duckdb-ollama-and-more.html",children:"check out a longer exploration here"}),"), but for our restaurant listing app, this suits our needs."]}),"\n",(0,t.jsx)(i.h2,{id:"enriching-data-with-gers-ids--producing-a-bridge-file",children:"Enriching data with GERS IDs & producing a bridge file"}),"\n",(0,t.jsx)(i.h3,{id:"enriching-our-table",children:"Enriching our table"}),"\n",(0,t.jsxs)(i.p,{children:["With our matcher written and tuned, let\u2019s add a column to our ",(0,t.jsx)(i.code,{children:"facilities"})," table named ",(0,t.jsx)(i.code,{children:"gers_id"})," and populate it with our join query above:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"ALTER TABLE inspections ADD COLUMN geometry VARCHAR;\nALTER TABLE inspections ADD COLUMN gers_id VARCHAR;\nWITH ranked_matches AS (\n    SELECT \n        f.Facility_ID as input_id, \n        f.Facility_Name as input_name, \n        f.Address as input_address, \n        p.id as match_id, \n        p.Facility_Name as match_name, \n        p.Address as match_address,\n        p.confidence as overture_confidence,\n        ST_Distance_Sphere(f.geom, p.geom) as distance, \n        jaro_winkler_similarity(f.Facility_Name, p.Facility_Name) as name_similarity, \n        jaro_winkler_similarity(f.Address, p.Address) as address_similarity,\n        ROW_NUMBER() OVER (\n            PARTITION BY f.Facility_ID\n            ORDER BY jaro_winkler_similarity(f.Facility_Name, p.Facility_Name) DESC\n        ) as rank\n    FROM facilities f\n    JOIN places p\n        ON ST_DWithin(f.geom, p.geom, 0.001)\n        AND jaro_winkler_similarity(f.Facility_Name, p.Facility_Name) > 0.89\n        AND jaro_winkler_similarity(f.Address, p.Address) > 0.75\n),\nselected_matches AS (\n    SELECT input_id, match_id FROM ranked_matches WHERE rank = 1\n)\nUPDATE inspections i SET gers_id = sm.match_id FROM selected_matches sm WHERE i.Facility_ID = sm.input_id;\n"})}),"\n",(0,t.jsxs)(i.p,{children:["Our ",(0,t.jsx)(i.code,{children:"facilities"})," table is now enriched with GERS identifiers."]}),"\n",(0,t.jsx)(i.p,{children:"We can use this association to connect county health scores with our Overture Places basemap, then display them to our app users."}),"\n",(0,t.jsxs)(i.p,{children:["Further, if we can share our association with others, allowing them to benefit from the hard work we\u2019ve done matching this data and easily connect it to their GERS-associated datasets using only a column join. One way to facilitate this is a ",(0,t.jsx)(i.em,{children:"bridge file"}),"."]}),"\n",(0,t.jsx)(i.h3,{id:"producing-a-bridge-file",children:"Producing a bridge file"}),"\n",(0,t.jsx)(i.p,{children:"A bridge file is a join table, connecting GERS identifiers with another set of identifiers. Overture produces bridge files for the data sources we use to produce our datasets, allowing others to understand the provenance of our data and to quickly enrich their own data with Overture datasets, if they\u2019re currently using one of our input data sources."}),"\n",(0,t.jsx)(i.p,{children:"Once you\u2019ve enriched your dataset with GERS identifiers, you can produce a bridge file like this:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"SELECT Facility_ID, gers_id FROM inspections WHERE gers_id IS NOT NULL GROUP BY Facility_ID, gers_id;\n"})}),"\n",(0,t.jsx)(i.p,{children:"Output this query as a CSV or parquet file and you\u2019re done. It looks like this:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"Facility_ID,gers_id\nFA0319719,08f28346e8ca018503160340e65ac7b6\nFA0319719,08f28346e8ca018503160340e65ac7b6\nFA0319719,08f28346e8ca018503160340e65ac7b6\nFA0002404,08f283098d6527200394e5ac0b19dbf5\nFA0002404,08f283098d6527200394e5ac0b19dbf5\n"})}),"\n",(0,t.jsx)(i.h2,{id:"performing-a-maintenance-match",children:"Performing a maintenance match"}),"\n",(0,t.jsx)(i.h3,{id:"associating-with-every-monthly-release",children:"Associating with every monthly release"}),"\n",(0,t.jsxs)(i.p,{children:["Overture currently releases a new version of its data every month. Our ",(0,t.jsx)(i.a,{href:"https://docs.overturemaps.org/release/latest/",children:"releases page"})," specifies its location and provides release notes."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Geospatial data never sleeps"}),". The real world is constantly changing, and in our case, restaurants are continually being opened and closed. Further, as Overture onboards new sources of data, the quality and coverage of our releases improves."]}),"\n",(0,t.jsx)(i.admonition,{type:"tip",children:(0,t.jsx)(i.p,{children:"Regularly associating your data with Overture\u2019s is considered best practice."})}),"\n",(0,t.jsx)(i.p,{children:"While rerunning a match for our ~4,000 restaurants is relatively quick, larger dataset associations can be quite costly. Thankfully, there are a few things we can take advantage of to make this process easier."}),"\n",(0,t.jsx)(i.h3,{id:"overture-data-changelog",children:"Overture data changelog"}),"\n",(0,t.jsxs)(i.p,{children:["With each data release, Overture generates a ",(0,t.jsx)(i.a,{href:"https://docs.overturemaps.org/gers/changelog/",children:"data changelog"})," to capture changes in the data tied to the GERS ID for each feature. This information can be used to help reduce the scope of our maintenance match by identifying associated GERS IDs which have changed."]}),"\n",(0,t.jsx)(i.p,{children:"Using our same DuckDB database, we can remotely query the current changelog using a bounding box defined by our inspections dataset."}),"\n",(0,t.jsx)(i.p,{children:"But wait \u2014 using the current March changelog won\u2019t yield very interesting results, since we\u2019ve already matched against the March data. For this exercise we\u2019ll redo our work above, this time referencing the previous, February, Overture release."}),"\n",(0,t.jsx)(i.h3,{id:"finding-a-subset-of-records-that-need-matching",children:"Finding a Subset of Records That Need Matching"}),"\n",(0,t.jsx)(i.p,{children:"Matching against the February data, we connect 2,366 of our facility IDs to GERS IDs. Let\u2019s see how the March changelog can help during our maintenance match."}),"\n",(0,t.jsx)(i.p,{children:"First, we\u2019ll cache the changelog in a table, filtered again by a bounding box:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"CREATE TABLE IF NOT EXISTS changes AS\nWITH bounding_box AS (\n    SELECT max(ST_Y(geom)) as max_lat, min(ST_Y(geom)) as min_lat, max(ST_X(geom)) as max_lon, min(ST_X(geom)) as min_lon\n    FROM facilities\n)\nSELECT \n    * \nFROM (\n    SELECT id, bbox, filename, change_type, theme \n    FROM read_parquet('s3://overturemaps-us-west-2/changelog/2025-03-19.1/theme=places/type=place/change_type=*/*', filename=true, hive_partitioning=1),\n            bounding_box\n    WHERE \n        bbox.xmin BETWEEN (bounding_box.min_lon - 0.01) AND (bounding_box.max_lon + 0.01) AND\n        bbox.ymin BETWEEN (bounding_box.min_lat - 0.01) AND (bounding_box.max_lat + 0.01)\n);\n"})}),"\n",(0,t.jsx)(i.p,{children:"This loads 87,229 records, which we\u2019ll now intersect with our existing, associated GERS IDs:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"SELECT Facility_ID, gers_id, change_type FROM inspections i \nJOIN changes c\nON i.gers_id = c.id\nGROUP BY Facility_ID, gers_id, change_type;\n"})}),"\n",(0,t.jsxs)(i.p,{children:["Of our 2,366 associated GERS, 61% are ",(0,t.jsx)(i.code,{children:"unchanged"}),". 37% have had ",(0,t.jsx)(i.code,{children:"data_changed"}),", in some form or another, but Overture\u2019s matchers have determined their GERS ID should persist \u2013 indicating that the record refers to the same entity."]}),"\n",(0,t.jsxs)(i.p,{children:["But ~1.5% of our matched GERS IDs \u2013 or 37 records \u2013 have been ",(0,t.jsx)(i.code,{children:"removed"}),". This could indicate a business has closed or a data record was identified as incorrect. Either way, this is a very small subset of records that we should rematch."]}),"\n",(0,t.jsxs)(i.p,{children:["Given our use case and our desire to produce a cautious match, we will also be rematching against the ",(0,t.jsx)(i.code,{children:"data_changed"})," records. There are many cases where a data update could correct an over-eager match based on incorrect input data."]}),"\n",(0,t.jsxs)(i.p,{children:["For our county restaurant inspection use case, our data volumes aren\u2019t of a sufficient size to really bother with this nuance (it\u2019s easier to just rematch against the new release and quickly compare the output to make sure nothing is breaking). But for much larger datasets, where matching routines might take hours, this list of ",(0,t.jsx)(i.code,{children:"removed"})," and ",(0,t.jsx)(i.code,{children:"data_changed"})," records is valuable."]}),"\n",(0,t.jsxs)(i.p,{children:["Let\u2019s build a new query which finds the subset of the ",(0,t.jsx)(i.code,{children:"Facility_ID"})," we should rematch. It\u2019s similar to our last one:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"SELECT Facility_ID, gers_id, change_type FROM inspections i \nLEFT JOIN changes c\nON i.gers_id = c.id\nWHERE change_type IS NULL OR change_type IN ['removed', 'data_changed']\nGROUP BY Facility_ID, gers_id, change_type;\n"})}),"\n",(0,t.jsxs)(i.p,{children:["We\u2019re using a ",(0,t.jsx)(i.code,{children:"LEFT JOIN"})," in this query to find the ",(0,t.jsx)(i.code,{children:"Facility_ID"}),"s which don\u2019t have associated GERS IDS (hence, they might match with a new Overture release) and only selecting those matched records where the associated GERS ID has been removed."]}),"\n",(0,t.jsx)(i.p,{children:"This gives us 2,804 facilities we need to match."}),"\n",(0,t.jsxs)(i.p,{children:["To simplify our SQL, we\u2019ll save the results from the above query as ",(0,t.jsx)(i.code,{children:"facilities_to_match"}),"."]}),"\n",(0,t.jsx)(i.h4,{id:"matching-unmatched-records-to-the-latest-release",children:"Matching Unmatched records to the latest release"}),"\n",(0,t.jsxs)(i.p,{children:["Armed with a shopping list of unmatched facilities, we can now drop our ",(0,t.jsx)(i.code,{children:"places"})," table and refresh it with the March Overture data, then create our spatial index."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"D DROP TABLE places;\nD CREATE TABLE places AS \n  WITH bounding_box AS (\n    SELECT max(ST_Y(geom)) as max_lat, min(ST_Y(geom)) as min_lat, max(ST_X(geom)) as max_lon, min(ST_X(geom)) as min_lon\n    FROM facilities\n  )\n  SELECT \n    id, \n    upper(names['primary']) as Facility_Name, \n    upper(addresses[1]['freeform']) as Address, \n    upper(addresses[1]['locality']) as City, \n    upper(addresses[1]['region']) as State, \n    left(addresses[1]['postcode'], 5) as Zip, \n    geometry as geom, \n    confidence,\n    categories \n  FROM (\n    SELECT * \n    FROM read_parquet('s3://overturemaps-us-west-2/release/2025-03-19.1/theme=places/type=place/*', filename=true, hive_partitioning=1),\n            bounding_box\n    WHERE addresses[1] IS NOT NULL AND\n        bbox.xmin BETWEEN (bounding_box.min_lon - 0.01) AND (bounding_box.max_lon + 0.01) AND\n        bbox.ymin BETWEEN (bounding_box.min_lat - 0.01) AND (bounding_box.max_lat + 0.01) AND\n        confidence > 0.3\n);\nD CREATE INDEX IF NOT EXISTS idx_places_geometry ON places USING RTREE (geom);\n"})}),"\n",(0,t.jsxs)(i.p,{children:["Finally, we run our match query again, limiting it to only those facilities in ",(0,t.jsx)(i.code,{children:"facilities_to_match"}),"."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"WITH ranked_matches AS (\n    SELECT \n        f.Facility_ID as input_id, \n        f.Facility_Name as input_name, \n        f.Address as input_address, \n        p.id as match_id, \n        p.Facility_Name as match_name, \n        p.Address as match_address,\n        p.confidence as overture_confidence,\n        ST_Distance_Sphere(f.geom, p.geom) as distance, \n        jaro_winkler_similarity(f.Facility_Name, p.Facility_Name) as name_similarity, \n        jaro_winkler_similarity(f.Address, p.Address) as address_similarity,\n        ROW_NUMBER() OVER (\n            PARTITION BY f.Facility_ID\n            ORDER BY jaro_winkler_similarity(f.Facility_Name, p.Facility_Name) DESC\n        ) as rank\n    FROM facilities f\n    JOIN places p\n        ON ST_DWithin(f.geom, p.geom, 0.001)\n        AND jaro_winkler_similarity(f.Facility_Name, p.Facility_Name) > 0.89\n        AND jaro_winkler_similarity(f.Address, p.Address) > 0.75\n    WHERE f.Facility_ID IN (SELECT Facility_ID FROM facilities_to_match)\n),\nselected_matches AS (\n    SELECT input_id, match_id FROM ranked_matches WHERE rank = 1\n)\nUPDATE inspections i SET gers_id = sm.match_id FROM selected_matches sm WHERE i.Facility_ID = sm.input_id;\n"})}),"\n",(0,t.jsx)(i.p,{children:"907 records were matched with this query, resulting in 2,358 total GERS associations."}),"\n",(0,t.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Geospatial matching is a pain"}),". However, by matching against Overture data once through a polished script or pipeline, you can seamlessly join with any other Global Entity Reference System (GERS) associated datasets. This integration makes your data more accessible, accelerates onboarding processes, and expands usability across teams that have also matched against GERS."]}),"\n",(0,t.jsx)(i.p,{children:"By leveraging GERS associations, teams can share the results of complex matching efforts and significantly enhance data value through simplified connections to additional datasets."})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},84708:(e,i,n)=>{n.d(i,{A:()=>a});const a=n.p+"assets/images/schema-comparison-43ccfb5b7dbe7900b2e890ddba6bdc4c.png"}}]);